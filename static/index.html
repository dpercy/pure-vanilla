<style>

  /* styles */
  textarea {
    font-family: Monaco, Consolas, monospace;
    font-size: 26px;
  }
  .error {
    font-color: red;
  }

  /* layout */
  #workspace {
    width: 100%;
    height: 100%;
    display: flex;
  }
  #workspace > * {
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
  }
  #workspace > * > * {
    width: 100%;
    height: 100%;
  }

  #graph {
    border: 1px solid #ddd;
  }

</style>

<div id="workspace">
  <div>
    <textarea placeholder="definitions" id="definitions"></textarea>
    <textarea disabled hidden id="def-errors" class="error"></textarea>
  </div>
  <div>
    <textarea placeholder="expression" id="query"></textarea>
    <textarea placeholder="result" disabled id="results"></textarea>
  </div>
  <div>
    <canvas id="graph">
    </canvas>
  </div>
</div>

<script>
  var defsWindow = document.getElementById('definitions');
  var defErrorsWindow = document.getElementById('def-errors');
  var queryWindow = document.getElementById('query');
  var resultsWindow = document.getElementById('results');

  // On page load, use addDefs with an empty list of new definitions
  // to query the current set of definitions.
  // Then use that to populate the initial definitions window.
  var xhr = new XMLHttpRequest();
  xhr.open("POST", "/addDefs", true);
  xhr.onreadystatechange = function() {
    if (xhr.readyState == 4 && xhr.status == 200) {
      defsWindow.value = xhr.responseText;
    }
  };
  xhr.send('');

  function redef() {
    var xhr = new XMLHttpRequest();
    xhr.open("POST", "/setDefs", true);
    xhr.onreadystatechange = function() {
      if (xhr.readyState == 4) {
        if (xhr.status == 200) {
          // yay
          console.log('setDefs', xhr.responseText);
          // whenever you redef, also requery,
          // since the query depends on the defs
          defErrorsWindow.value = '';
	  defErrorsWindow.hidden = true;
          requery();
        } else {
          // error
          console.log('setDefs error', xhr.responseText);
          defErrorsWindow.value = xhr.responseText;
	  defErrorsWindow.hidden = false;
        }
      }
    };
    xhr.send(defsWindow.value);

    getResidualDefs();
  }
  defsWindow.addEventListener('keyup', redef);

  function getResidualDefs() {
    var xhr = new XMLHttpRequest();
    xhr.open("POST", "/residualDefs", true);
    xhr.onreadystatechange = function() {
      if (xhr.readyState == 4) {
	if (xhr.status == 200) {
          // yay
          console.log('residualDefs', xhr.responseText);
	  eval("window.defs = " + xhr.responseText);
	  redraw();
	} else {
          // error
          console.log('residualDefs error', xhr.responseText);
          defErrorsWindow.value = xhr.responseText;
	  defErrorsWindow.hidden = false;
	}
      }
    };
    xhr.send();
  }
  getResidualDefs();

  function requery() {
    if (queryWindow.value.trim() === '') {
      resultsWindow.value = '';
    } else {
      var xhr = new XMLHttpRequest();
      xhr.open("POST", "/query", true);
      xhr.onreadystatechange = function() {
	if (xhr.readyState == 4) {
	  if (xhr.status == 200) {
    	    // yay
    	    resultsWindow.value = xhr.responseText;
	    resultsWindow.classList.remove('error');
    	    console.log('interactions result', xhr.responseText);
    	  } else {
    	    // error
    	    resultsWindow.value = xhr.responseText;
	    resultsWindow.classList.add('error');
    	    console.log('interactions error', xhr.responseText);
    	  }
	}
      };
      xhr.send(queryWindow.value);
    }
  }
  queryWindow.addEventListener('keyup', requery);


  var graph = document.getElementById('graph');
  var pixelsPerUnit = 30;
  var originX = 0;
  var originY = 0;
  function redraw() {
    // set up the context
    var ctx = graph.getContext('2d');
    graph.width = graph.parentElement.clientWidth;
    graph.height = graph.parentElement.clientHeight;
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0, 0, graph.width, graph.height);

    // define some "manual transformation" variables:
    // we'll keep the canvas in pixel-space and convert point-sets manually
    pixelsPerUnit = 30;
    originX = graph.width/2;
    originY = graph.height/2;

    // draw axis ticks
    ctx.strokeStyle = "#888";
    var tickLen = 5;
    for (var sign=-1; sign<2; sign+=2) {
      for (var x=1; x<100; ++x) {
	ctx.beginPath();
	ctx.moveTo(originX + sign*x*pixelsPerUnit, originY + 0);
	ctx.lineTo(originX + sign*x*pixelsPerUnit, originY - tickLen);
	ctx.stroke();
      }
      for (var y=1; y<100; ++y) {
	ctx.beginPath();
	ctx.moveTo(originX,           originY + sign*y*pixelsPerUnit);
	ctx.lineTo(originX + tickLen, originY + sign*y*pixelsPerUnit);
	ctx.stroke();
      }
    }

    // draw axes
    ctx.lineWidth = 1;
    ctx.strokeStyle = "#666";

    ctx.beginPath();
    ctx.moveTo(0, originY);
    ctx.lineTo(graph.width, originY);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(originX, 0);
    ctx.lineTo(originX, +graph.height);
    ctx.stroke();


    // draw functions
    // - determine the domain to use
    var screenRight = (graph.width - originX)/pixelsPerUnit;
    var screenLeft = (0 - originX)/pixelsPerUnit;
    var numSamples = 100;
    var sampleSpacing = (graph.width/pixelsPerUnit) / numSamples;
    var domain = [];
    for (var x=screenLeft; x<=screenRight+sampleSpacing; x+=sampleSpacing) {
      domain.push(x);
    }

    // - draw individual functions
    Object.keys(window.defs).forEach(defName => {
      var defValue = window.defs[defName];

      if (typeof defValue === 'function') {
	drawFunction(ctx, domain, defValue);
      }
    });
  }
  window.addEventListener('resize', redraw);


  function drawFunction(ctx, domain, func) {
    drawLine(ctx, domain, domain.map(func));
  }
  function drawLine(ctx, xs, ys) {
    // xs and ys are in math coordinates.
    // we need to draw them in pixel coordinates.
    ctx.strokeStyle = "#00c";
    ctx.beginPath();
    ctx.moveTo(originX + pixelsPerUnit * xs[0],
	       originY - pixelsPerUnit * ys[0]);
    for (var i=1; i<xs.length; ++i) {
      ctx.lineTo(originX + pixelsPerUnit * xs[i],
		 originY - pixelsPerUnit * ys[i]);
    }
    ctx.stroke();
  }
  

</script>
