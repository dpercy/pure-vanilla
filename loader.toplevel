(module Util
    #;()
  (= map
     (lambda (f lst)
       (if (Builtin.isEmpty lst)
           '()
           (Builtin.link (f (Builtin.first lst))
                         (map f (Builtin.rest lst))))))
  (= foreach
     (lambda (f lst)
       (if (Builtin.isEmpty lst)
           (Builtin.void)
           (begin (f (Builtin.first lst))
                  (foreach f (Builtin.rest lst))))))

  (= second
     (lambda (v) (Builtin.first (Builtin.rest v))))

  (= not (lambda (v) (if v #false #true)))

  (= list (Builtin.makeVariadic (lambda (lst) lst)))

  (= > (lambda (x y) (Builtin.< y x)))
  (= >= (lambda (x y) (not (Builtin.< x y))))
  (= <= (lambda (x y) (>= y x)))

  (= length
     (lambda (lst)
       (if (Builtin.isEmpty lst)
           0
           (Builtin.+ 1 (length (Builtin.rest lst))))))

  (= cases
     (lambda (msg ast handlers)
       (if (Builtin.isEmpty handlers)
           (Builtin.error (Util.list "no case in" msg "for ast" ast))
           (let* ([tag (Builtin.first (Builtin.first handlers))]
                  [handler (second (Builtin.first handlers))]
                  [unpacked (Builtin.untag tag ast)])
             (if unpacked
                 (Builtin.apply handler unpacked)
                 (cases msg ast (Builtin.rest handlers)))))))
  (= hasTag (lambda (v tag)
              (not (Builtin.== #false (Builtin.untag tag v)))))

  (= foldr (lambda (f base lst)
             (if (Builtin.isEmpty lst)
                 base
                 (f (Builtin.first lst)
                    (foldr f base (Builtin.rest lst))))))

  (= append2 (lambda (a b) (foldr Builtin.link b a)))
  (= append (Builtin.makeVariadic (lambda (lists) (foldr append2 '() lists))))

  (= filter (lambda (pred lst)
              (if (Builtin.isEmpty lst)
                  '()
                  (if (pred (Builtin.first lst))
                      (Builtin.link (Builtin.first lst) (filter pred (Builtin.rest lst)))
                      (filter pred (Builtin.rest lst))))))

  (= count (lambda (pred lst)
             (length (filter pred lst))))

  (= remove (lambda (elem lst)
              (filter (lambda (x) (if (Builtin.== elem x) #false #true)) lst)))

  (= any (lambda (pred lst)
           (cond
             [(Builtin.isEmpty lst) #false]
             [(pred (Builtin.first lst)) #true]
             [else (any pred (Builtin.rest lst))])))

  (= contains (lambda (lst elem)
                (any (lambda (x) (Builtin.== x elem)) lst)))

  (= explode (lambda (string)
               (if (Builtin.== (Builtin.strlen string) 0)
                   '()
                   (Builtin.link (Builtin.slice string 0 1)
                                 (explode (Builtin.slice string 1)))))))

(module Lexer
    #;()

  #|

  delimiters:
  ()[]{},                               ;

  TODO add qualified idens and ops
  - no space allowed around dot - dot is not a separate token

  iden := ( alpha | "_" ) ( alpha | digit | "_" )*

  num := digit+

  op := symbol+
  where symbol is any non-alpha, non-digit, non-whitespace, non-comment-start, non-delimiter

  string := doublequote ( nonquotenonbackslash | escapesequence )* doublequote

  - fixed tokens are represented by strings: "eof", "(", "\n", etc


  |#

  (= makeConstructor1
     (lambda (t) (lambda (a)
                   (Builtin.tag t (Util.list a)))))

  (= makePredicate
     (lambda (t)
       (lambda (v)
         (Util.not (== #false (Builtin.untag t v))))))

  (= Iden (makeConstructor1 #'Iden)) ; holds the iden as a string, like "myIden123"
  (= Op   (makeConstructor1 #'Op)) ; holds the iden as a string, like "<"
  (= Num  (makeConstructor1 #'Num)) ; holds the number value, like 123, NOT "123"
  (= Str  (makeConstructor1 #'Str)) ; holds the *value* of the string, like "\t"; NOT "\"\\t\""

  (= isIden (makePredicate #'Iden))
  (= isOp   (makePredicate #'Op))
  (= isNum  (makePredicate #'Num))
  (= isStr  (makePredicate #'Str))

  (= ord Builtin.ord)
  (= < Builtin.<)
  (= <= Util.<=)
  (= + Builtin.+)
  (= - Builtin.-)
  (= * Builtin.*)
  (= == Builtin.==)

  (= delimiters (Util.explode "()[]{},;\n"))
  (= isDelimiter (lambda (c) (Util.contains delimiters c)))

  (= opchars (Util.explode "~!@$%^&*_-+=:<>/?"))
  (= isOpchar (lambda (c) (Util.contains opchars c)))

  (= isDigit (lambda (c) (and (<= (ord "0") (ord c)) (<= (ord c) (ord "9")))))
  (= isLower (lambda (c) (and (<= (ord "a") (ord c)) (<= (ord c) (ord "z")))))
  (= isUpper (lambda (c) (and (<= (ord "A") (ord c)) (<= (ord c) (ord "Z")))))
  (= isAlpha (lambda (c) (or (isLower c) (isUpper c))))

  (= isIdenStart (lambda (c) (or (== "_" c) (isAlpha c))))
  (= isIdenChar (lambda (c) (or (isIdenStart c) (isDigit c))))

  (= lexAll
     (lambda (string)                   ; -> listof token
       (let* ([tokAndRest (lex string)]
              [tok (Builtin.first tokAndRest)]
              [rest (Util.second tokAndRest)])
         (if (== tok "eof")
             '()
             (Builtin.link tok (lexAll rest))))))

  (= seekWhile
     (lambda (pred string)              ; index
       ; return the first index in the string that fails the predicate
       (seekWhileLoop pred string 0)))
  (= seekWhileLoop
     (lambda (pred string idx)          ; index
       (if (== idx (Builtin.strlen string))
           idx
           (let ([c (Builtin.slice string idx (+ idx 1))])
             (if (pred c)
                 (seekWhileLoop pred string (+ idx 1))
                 idx)))))

  ; TODO may need to trampoline this on implementations with small stacks:
  ;  - add a function Builtin.trampoline
  (= lex
     (lambda (string)                   ; -> [token-or-eof, string]
       (let ([string (eatWhitespaceAndComments string)])
         (if (== 0 (Builtin.strlen string))
             (Util.list "eof" string)
             (let ([c (Builtin.slice string 0 1)])
               (cond
                 [(isDelimiter c) (Util.list c (Builtin.slice string 1))]
                 [(isIdenStart c) (lexIden string)]
                 [(isDigit c) (lexNumber string)]
                 [(isOpchar c) (lexOp string)]
                 [(== c "\"") (lexStringContents "" (Builtin.slice string 1))]
                 [else (Builtin.error (Util.list "lex: unexpected character:" c))]))))))

  (= keywords (Util.list "if" "then" "else"
                         "fn" "->"))
  (= isKeyword (lambda (s) (Util.contains keywords s)))

  (= lexIden
     (lambda (string)
       (let* ([idx (seekWhile isIdenChar string)]
              [prefix (Builtin.slice string 0 idx)]
              [suffix (Builtin.slice string idx)]
              [tok (if (isKeyword prefix)
                       prefix
                       (Iden prefix))])
         (Util.list tok suffix))))

  (= lexNumber
     (lambda (string)
       (let* ([idx (seekWhile isIdenChar string)]
              [prefix (Builtin.slice string 0 idx)]
              [suffix (Builtin.slice string idx)]
              [tok (Num (intOfString prefix))])
         ; leave the number as a string because the toplevel implementation
         ; might not support very wide integers
         (Util.list tok suffix))))
  (= intOfString
     (lambda (string)
       (if (== (Builtin.strlen string) 0)
           0
           (let ([last (Builtin.slice string (- (Builtin.strlen string) 1) (Builtin.strlen string))]
                 [butlast (Builtin.slice string 0 (- (Builtin.strlen string) 1))])
             (+ (- (ord last) (ord "0"))
                (* 10 (intOfString butlast)))))))

  (= lexOp
     (lambda (string)
       (let* ([idx (seekWhile isOpchar string)]
              [prefix (Builtin.slice string 0 idx)]
              [suffix (Builtin.slice string idx)]
              [tok (if (isKeyword prefix)
                       prefix
                       (Op prefix))])
         (Util.list tok suffix))))

  (= lexStringContents
     (lambda (prefix string)            ; [token, string]
       (let* ([idx (seekWhile (lambda (c)
                                (Util.not (or (== c "\"")
                                              (== c "\\"))))
                              string)])
         (if (== (Builtin.strlen string) idx)
             (Builtin.error "lex: unexpected newline in string")
             (let ([c (Builtin.slice string idx (+ idx 1))])
               (cond
                 [(== c "\"") (let* ([beforeQuote (Builtin.slice string 0 idx)]
                                     [afterQuote (Builtin.slice string (+ idx 1))]
                                     [s (Builtin.strcat prefix beforeQuote)])
                                (Util.list (Str s) afterQuote))]
                 [(== c "\\") (Builtin.error "TODO interpret escapes")]
                 [else (Builtin.error (Util.list "no case in lexStringContents for" c))]))))))

  (= eatWhitespaceAndComments
     (lambda (string)                   ; -> string
       (if (== 0 (Builtin.strlen string))
           string
           (let ([c (Builtin.slice string 0 1)])
             (cond
               [(== c " ") (eatWhitespaceAndComments (Builtin.slice string 1))]
               [(== c "\t") (eatWhitespaceAndComments (Builtin.slice string 1))]
               [(== c "#") (let ([idx (seekWhile (lambda (c) (Util.not (== "\n" c)))
                                                 string)])
                             (eatWhitespaceAndComments (Builtin.slice string idx)))]
               [else string]))))))

(module Scope
    #;()
  (= Scope #'Scope.Scope)
  (= emptyScope (Builtin.tag Scope (Util.list #false '())))
  ; left value of a scope is the current module name, or false
  ; right value is a list of bound names

  (= setModname (lambda (scope modname)
                  (let ([{_ bound} (Builtin.untag Scope scope)])
                    (Builtin.tag Scope (Util.list modname bound)))))
  (= getModname (lambda (scope)
                  (let ([{mn _} (Builtin.untag Scope scope)])
                    mn)))

  (= add (lambda (name scope)
           (let ([{mn bound} (Builtin.untag Scope scope)])
             (Builtin.tag Scope (Util.list mn (Builtin.link name bound))))))
  (= lookup (lambda (scope)
              (lambda (name)
                (let* ([{mn bound} (Builtin.untag Scope scope)]
                       [numBound (Util.count (lambda (b) (Builtin.== b name))
                                             bound)])
                  (if (Builtin.== 0 numBound)
                      (Builtin.tag #'Syntax.Global (Util.list mn name))
                      (Builtin.tag #'Syntax.Local (Util.list name (Builtin.- numBound 1)))))))))

(module Parser
    #;()

  #|

  grammar:

  def := expr = expr

  parseExpr :
  .  peek:
  .   - if -> parse an if
  .   - fn -> parse a fn
  .   - open -> parse a subexpr
  .   - otherwise -> parseCall

  parseCall :
  .  - parseAtom
  .  peek:
  .   - if open paren: parse the args, then parseCall

  ; TODO add local binding (preparing for bootstrap)
  ;   - ideally, the one local binding construct to rule them all: letrec*
  ;   - need a very simple implementation of letrec* in the interpreter
  ;      - but also needs destructuring bind for lists??
  ;      - how does shadowing work??

  use splicing-local somehow as the lone shadowing operator?
  x = # sees *nothing*
  local {
  a = # sees x, a, b
  b = # sees x, a, b
  } in {
  f = # sess x,
  }

  or, any repeated variable is implicitly shadowed?
  maybe confusing:
  { a = 1; f = () -> a }  # f sees a = 1
  { f = () -> a; a = 2 }  # f sees a = 2
  { a = 1; f = () -> a; a = 2 }  # f sees which one???

  or, function bodies see things recursively; other things see things iteratively.
  and raise an explicit error when it's ambiguous.
  { a = 1; a = a + 1; } # shadow inc
  { f = () -> f; }  # f returns itself
  { a = 1; a = 2; f = () -> a; }  # error: which a do you mean? please rename something.

  or think of it this way:
  you could always resort to nested letrecs to get shadowing:
  { a = 1; { a = a + 1; { a = a + 1; print(a) } } }
  so what we need is just a shortcut to do that without adding indentation.
  could that keyword be `let`?
  a = 1
  let a = a + 2
  problem is that makes it sound like it applies just to `a`.

  What about basing it all on shadow_unrelated?
  https://github.com/Manishearth/rust-clippy/wiki#shadow_unrelated
  - a = E[ a ]  does shadowing
  - a = E[ fn() -> E[ a ] ]  does recursive something something??
  - a = 1; a = 2  is disallowed!!!

  OR just do OCaml letrec thing. shadow by default; explicit rec { } block for rec.



  ; TODO try to bootstrap the parser!
  ;   - transcribe this file into the new syntax
  ;   - serialize this file as JSON

  |#

  ; Lexer.lex : string -> [token-or-eof, string]
  (= == Builtin.==)
  (= list Util.list)
  (= first Builtin.first)
  (= second Util.second)

  (= peek (lambda (string) (first (Lexer.lex string))))
  (= skip (lambda (string) (second (Lexer.lex string))))
  (= expect (lambda (tok string)        ; -> string
              (let ([(tok2 string) (Lexer.lex string)])
                (if (== tok tok2)
                    string
                    (Builtin.error (list "expected" tok "but got" tok2))))))

  (= parseProgram
     (lambda (scope string)                   ; -> listof def-or-expr
       (if (== "eof" (peek string))
           '()
           (let ([{def string} (parseDef scope string)])
             (Builtin.link def
                           (parseProgram scope string))))))

  (= parseDef
     (lambda (scope string)                   ; -> [def-or-expr, string]
       (let ([{expr string} (parseExpr scope string)])
         (if (== "=" (peek string))
             ; parse another expr
             (let ([{expr2 string} (Lexer.lex string)])
               (list (Builtin.tag #'Syntax.Def (list expr expr2))
                     string))
             ; just do this one
             (list expr string)))))

  (= parseExpr
     (lambda (scope string)                   ; -> [expr, string]
       (let ([tok (peek string)])
         (cond
           [(== tok "if") (parseIf scope string)]
           [(== tok "fn") (parseFn scope string)]
           [else (parseCall scope string)]))))

  (= parseIf
     (lambda (scope s)                        ; -> [expr, string]
       (let* ([s         (expect "if" s)]
              [{test s}  (parseExpr scope s)]
              [s         (expect "then" s)]
              [{consq s} (parseExpr scope s)]
              [s         (expect "else" )]
              [{alt s}   (parseExpr scope s)])
         (list (Builtin.tag #'Syntax.If (list test consq alt))
               s))))

  (= parseFn
     (lambda (scope s)                        ; -> [expr, string]
       (let* ([s (expect "fn" s)]
              [s (expect "(" s)]
              [{paramNames s} (parseParamNames scope s)]
              [scope (Util.foldr Scope.add scope paramNames)]
              [params (Util.map (Scope.lookup scope) paramNames)]
              [s (expect ")" s)]
              [s (expect "->" s)]
              [{body s} (parseExpr scope s)])
         (list (Builtin.tag #'Syntax.Func (list params body))
               s))))
  (= parseParamNames
     (lambda (scope s)
       (let ([tok (peek s)])
         (cond
           [(Lexer.isIden tok)  (let* ([{name} (Builtin.untag #'Lexer.Iden tok)]
                                       [s (skip s)])
                                  (if (== (peek s) ",")
                                      (let* ([s (skip s)]
                                             [{restParamNames s} (parseParamNames scope s)])
                                        (Util.list (Builtin.link name restParamNames)
                                                   s))
                                      (Util.list (Util.list name)
                                                 s)))]
           [else (Util.list '() s)]))))

  (= parseCall
     (lambda (scope s)
       (let ([{head s} (parseAtom scope s)])
         (parseCallLoop scope head s))))
  (= parseCallLoop
     (lambda (scope callee s)
       (let ([tok (peek s)])
         (if (== tok "(")
             (let ([{args s} (parseParenArgs scope s)])
               (parseCallLoop scope
                              (Builtin.tag #'Syntax.Call (list callee args))
                              s))
             (list callee s)))))
  (= parseParenArgs
     (lambda (scope s)
       (let* ([s (expect "(" s)]
              [{es s} (parseArgs scope s)]
              [s (expect ")" s)])
         (list es s))))
  (= parseArgs
     (lambda (scope s)
       (if (== (peek s) ")")
           (list '() s)
           (let ([{e s} (parseExpr scope s)])
             (if (== (peek s) ")")
                 (list (list e) s)
                 (let* ([s (expect "," s)]
                        [{rest s} (parseArgs scope s)])
                   (list (Builtin.link e rest) s)))))))

  (= parseAtom
     (lambda (scope s)
       (let ([tok (peek s)])
         (cond
           [(== tok "(") (parseParen scope s)]
           [(Lexer.isIden tok) (let ([{name} (Builtin.untag #'Lexer.Iden tok)])
                                 (list ((Scope.lookup scope) name)
                                       (skip s)))]
           [(Lexer.isNum tok) (let ([{val} (Builtin.untag #'Lexer.Num tok)])
                                (list (Builtin.tag #'Syntax.Lit (list val))
                                      (skip s)))]
           [(Lexer.isStr tok) (let ([{val} (Builtin.untag #'Lexer.Str tok)])
                                (list (Builtin.tag #'Syntax.Lit (list val))
                                      (skip s)))]
           [else (Builtin.error (list "no case in parseAtom" tok))]))))

  (= parseParen
     (lambda (scope s)                   ; -> [expr, string]
       (let* ([s (expect "(" s)]
              [(e s) (parseExpr scope s)])
         (list e (expect ")" s)))))


  ;;
  )

(module Loader
    #;()

  (= runModule
     (lambda (modname)
       (runModuleHelper modname '())))
  (= runModuleHelper
     (lambda (modname seen)
       (cond
         [(System.moduleExists modname) "already exists"]
         [(Util.contains seen modname) (Builtin.error (Util.list "cyclic module dependency:" seen))]
         [else
          ; interpret modname as a filename
          (let* ([text (System.readFile modname)]
                 [ast (System.parse text)]
                 [_ (verifyModule ast)]
                 [deps (Util.remove modname (scan ast))]
                 [_ (let* ([seen (Builtin.link modname seen)]
                           [runModule (lambda (modname) (runModuleHelper modname seen))])
                      (Util.foreach runModule deps))]
                 [mod (System.eval ast)])
            (System.registerModule mod))])))

  (= verifyModule
     (lambda (ast)
       (Util.cases
        "outer cases in verifyModule"
        ast
        ; unbound locals
        ; defs match the modname
        ; duplicate defs and params
        (Util.list
         (Util.list #'Syntax.Module
                    (lambda (modname statements)
                      ; get def LHSes:
                      (begin
                        (let* ([lhses (Util.map
                                       (lambda (stmt)
                                         (let ([unpacked (Builtin.untag #'Syntax.Def stmt)])
                                           (if unpacked
                                               (Builtin.first unpacked)
                                               #false)))
                                       statements)]
                               [lhses (Util.filter (lambda (x) x) lhses)]
                               ; - check are all globals
                               [lhsNames
                                (Util.map
                                 (lambda (lhs)
                                   (Util.cases
                                    "inner cases in verifyModule"
                                    lhs
                                    (Util.list (Util.list #'Syntax.Global
                                                          (lambda (mod name)
                                                            ; - check modname matches
                                                            (if (Builtin.== mod modname)
                                                                name
                                                                (Builtin.error "def modname mismatch")))))))
                                 lhses)])
                          ; - check no dupes
                          (verifyDistinct lhsNames))
                        (let ([exprs (Util.map
                                      (lambda (stmt)
                                        (let ([unpacked (Builtin.untag #'Syntax.Def stmt)])
                                          (if unpacked
                                              (Util.second unpacked)
                                              stmt)))
                                      statements)])
                          (Util.foreach (lambda (e) (verifyExpr e '())) exprs)))))))))
  (= verifyExpr
     (lambda (ast env) ; env : listof local
       (let ([r (lambda (ast) (verifyExpr ast env))])
         (Util.cases
          "cases in verifyExpr"
          ast
          (Util.list
           (Util.list #'Syntax.Module (lambda (modname statements)
                                        (Builtin.error (Util.list "not an expression:" ast))))
           (Util.list #'Syntax.Using (lambda (modname)
                                       (Builtin.error (Util.list "not an expression:" ast))))
           (Util.list #'Syntax.Def (lambda (var expr)
                                     (Builtin.error (Util.list "not an expression:" ast))))
           (Util.list #'Syntax.Lit (lambda (value)
                                     ; TODO what kind of values can go in a literal?
                                     ;  - all values?
                                     ;  - only values that can be parsed?
                                     ;  - only atomic values?
                                     (Builtin.void)))
           (Util.list #'Syntax.Quote (lambda (subast)
                                       ; ??? check more?
                                       (Builtin.void)))
           (Util.list #'Syntax.Global (lambda (mod name)
                                        ; ??? check mod is not false?
                                        (Builtin.void)))
           (Util.list #'Syntax.Local (lambda (name number)
                                       (if (Util.contains env ast)
                                           (Builtin.void)
                                           (Builtin.error (Util.list "unbound local" ast)))))
           (Util.list #'Syntax.Func (lambda (params body)
                                      (let* ([names (Util.map getLocalName params)]
                                             [_ (verifyDistinct names)]
                                             [env (append params env)])
                                        (verifyExpr body env))))
           (Util.list #'Syntax.Call (lambda (func args)
                                      (begin
                                        (r func)
                                        (Util.foreach r args))))
           (Util.list #'Syntax.If (lambda (test consq alt)
                                    (begin
                                      (r test)
                                      (r consq)
                                      (r alt)))))))))
  (= getLocalName
     (lambda (param)
       (Util.cases
        "cases in getLocalName"
        param
        (Util.list (Util.list #'Syntax.Local
                              (lambda (name num) name))))))
  (= verifyDistinct
     (lambda (names)
       (cond
         [(Builtin.isEmpty names) (Builtin.void)]
         [(Util.contains (Builtin.rest names)
                         (Builtin.first names)) (Builtin.error (Util.list "duplicate name:" (first names)))]
         [else (verifyDistinct (Builtin.rest names))])))



  (= scan
     (lambda (ast) ; -> list of
       (Util.cases
        "cases in scan"
        ast
        (Util.list
         (Util.list #'Syntax.Global (lambda (mod name) (Util.list mod)))
         (Util.list #'Syntax.Module (lambda (modname statements) (scanMany statements)))
         (Util.list #'Syntax.Using (lambda (modname) (Util.list)))
         (Util.list #'Syntax.Def (lambda (var expr) (scan expr)))
         (Util.list #'Syntax.Lit (lambda (value) (Util.list)))
         (Util.list #'Syntax.Quote (lambda (subast) (scan subast)))
         (Util.list #'Syntax.Local (lambda (name number) (Util.list)))
         (Util.list #'Syntax.Func (lambda (params body) (scan body)))
         (Util.list #'Syntax.Call (lambda (func args) (scanMany (Builtin.link func args))))
         (Util.list #'Syntax.If (lambda (test consq alt) (scanMany (Util.list test consq alt))))))))
  (= scanMany
     (lambda (asts)
       (Builtin.apply Util.append (Util.map scan asts)))))

(let ([args (System.getArgs)])
  (if (Builtin.isEmpty args)
      (Builtin.error "specify a main module")
      (Loader.runModule (Builtin.first args))))
