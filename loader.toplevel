(module Util
    #;()
  (= map
     (lambda (f lst)
       (if (Builtin.isEmpty lst)
           '()
           (Builtin.link (f (Builtin.first lst))
                         (map f (Builtin.rest lst))))))
  (= foreach
     (lambda (f lst)
       (if (Builtin.isEmpty lst)
           (Builtin.void)
           (begin (f (Builtin.first lst))
                  (foreach f (Builtin.rest lst))))))

  (= second
     (lambda (v) (Builtin.first (Builtin.rest v))))

  (= not (lambda (v) (if v #false #true)))

  (= list (Builtin.makeVariadic (lambda (lst) lst)))

  (= > (lambda (x y) (Builtin.< y x)))
  (= >= (lambda (x y) (not (Builtin.< x y))))
  (= <= (lambda (x y) (>= y x)))

  (= cases
     (lambda (ast handlers)
       (if (Builtin.isEmpty handlers)
           (Builtin.error (Util.list "no case for ast" ast))
           (let* ([tag (Builtin.first (Builtin.first handlers))]
                  [handler (second (Builtin.first handlers))]
                  [unpacked (Syntax.unpack tag ast)])
             (if unpacked
                 (Builtin.apply handler unpacked)
                 (cases ast (Builtin.rest handlers)))))))
  (= hasTag (lambda (v tag)
              (not (Builtin.== #false (Syntax.unpack tag v)))))

  (= foldr (lambda (f base lst)
             (if (Builtin.isEmpty lst)
                 base
                 (f (Builtin.first lst)
                    (foldr f base (Builtin.rest lst))))))

  (= append2 (lambda (a b) (foldr Builtin.link b a)))
  (= append (Builtin.makeVariadic (lambda (lists) (foldr append2 '() lists))))

  (= filter (lambda (pred lst)
              (if (Builtin.isEmpty lst)
                  '()
                  (if (pred (Builtin.first lst))
                      (Builtin.link (Builtin.first lst) (filter pred (Builtin.rest lst)))
                      (filter pred (Builtin.rest lst))))))

  (= remove (lambda (elem lst)
              (filter (lambda (x) (if (Builtin.== elem x) #false #true)) lst)))

  (= any (lambda (pred lst)
           (cond
             [(Builtin.isEmpty lst) #false]
             [(pred (Builtin.first lst)) #true]
             [else (any pred (Builtin.rest lst))])))

  (= contains (lambda (lst elem)
                (any (lambda (x) (Builtin.== x elem)) lst)))

  (= explode (lambda (string)
               (if (Builtin.== (Builtin.strlen string) 0)
                   '()
                   (Builtin.link (Builtin.slice string 0 1)
                                 (explode (Builtin.slice string 1)))))))

(module Lexer
    #;()

  #|

  delimiters:
  ()[]{},;

  TODO add qualified idens and ops
  - no space allowed around dot - dot is not a separate token

  iden := ( alpha | "_" ) ( alpha | digit | "_" )*

  num := digit+

  op := symbol+
  where symbol is any non-alpha, non-digit, non-whitespace, non-comment-start, non-delimiter

  string := doublequote ( nonquotenonbackslash | escapesequence )* doublequote

  - fixed tokens are represented by strings: "eof", "(", "\n", etc


  |#

  (= makeConstructor1
     (lambda (t) (lambda (a)
                   (Builtin.tag t (Util.list a)))))

  (= Iden (makeConstructor1 #'Iden)) ; holds the iden as a string, like "myIden123"
  (= Op   (makeConstructor1 #'Op))   ; holds the iden as a string, like "<"
  (= Num  (makeConstructor1 #'Num))  ; holds the number as a string, like "123"
  (= Str  (makeConstructor1 #'Str))  ; holds the *value* of the string, like "\t"; NOT "\"\\t\""

  (= ord Builtin.ord)
  (= < Builtin.<)
  (= <= Util.<=)
  (= + Builtin.+)
  (= == Builtin.==)

  (= delimiters (Util.explode "()[]{},;\n"))
  (= isDelimiter (lambda (c) (Util.contains delimiters c)))

  (= ops (Util.explode "~!@$%^&*_-+=:<>/?"))
  (= isOp (lambda (c) (Util.contains ops c)))

  (= isDigit (lambda (c) (and (<= (ord "0") (ord c)) (<= (ord c) (ord "9")))))
  (= isLower (lambda (c) (and (<= (ord "a") (ord c)) (<= (ord c) (ord "z")))))
  (= isUpper (lambda (c) (and (<= (ord "A") (ord c)) (<= (ord c) (ord "Z")))))
  (= isAlpha (lambda (c) (or (isLower c) (isUpper c))))

  (= isIdenStart (lambda (c) (or (== "_" c) (isAlpha c))))
  (= isIden (lambda (c) (or (isIdenStart c) (isDigit c))))

  (= lexAll
     (lambda (string) ; -> listof token
       (let* ([tokAndRest (lex string)]
              [tok (Builtin.first tokAndRest)]
              [rest (Util.second tokAndRest)])
         (if (== tok "eof")
             '()
             (Builtin.link tok (lexAll rest))))))

  (= seekWhile
     (lambda (pred string) ; index
       ; return the first index in the string that fails the predicate
       (seekWhileLoop pred string 0)))
  (= seekWhileLoop
     (lambda (pred string idx) ; index
       (if (== idx (Builtin.strlen string))
           idx
           (let ([c (Builtin.slice string idx (+ idx 1))])
             (if (pred c)
                 (seekWhileLoop pred string (+ idx 1))
                 idx)))))

  ; TODO may need to trampoline this on implementations with small stacks:
  ;  - add a function Builtin.trampoline
  (= lex
     (lambda (string) ; -> [token-or-eof, string]
       (let ([string (eatWhitespaceAndComments string)])
         (if (== 0 (Builtin.strlen string))
             (Util.list "eof" string)
             (let ([c (Builtin.slice string 0 1)])
               (cond
                 [(isDelimiter c) (Util.list c (Builtin.slice string 1))]
                 [(isIdenStart c) (lexIden string)]
                 [(isDigit c) (lexNumber string)]
                 [(isOp c) (lexOp string)]
                 [(== c "\"") (lexStringContents "" (Builtin.slice string 1))]
                 [else (Builtin.error (Util.list "lex: unexpected character:" c))]))))))

  (= keywords (Util.list "if" "then" "else"
                         "fn" "->"))
  (= isKeyword (lambda (s) (Util.contains keywords s)))

  (= lexIden
     (lambda (string)
       (let* ([idx (seekWhile isIden string)]
              [prefix (Builtin.slice string 0 idx)]
              [suffix (Builtin.slice string idx)]
              [tok (if (isKeyword prefix)
                       prefix
                       (Iden prefix))])
         (Util.list tok suffix))))

  (= lexNumber
     (lambda (string)
       (let* ([idx (seekWhile isIden string)]
              [prefix (Builtin.slice string 0 idx)]
              [suffix (Builtin.slice string idx)]
              [tok (Num prefix)])
         ; leave the number as a string because the toplevel implementation
         ; might not support very wide integers
         (Util.list tok suffix))))

  (= lexOp
     (lambda (string)
       (let* ([idx (seekWhile isOp string)]
              [prefix (Builtin.slice string 0 idx)]
              [suffix (Builtin.slice string idx)]
              [tok (if (isKeyword prefix)
                       prefix
                       (Op prefix))])
         (Util.list tok suffix))))

  (= lexStringContents
     (lambda (prefix string) ; [token, string]
       ; TODO get characters one by one, interpreting escapes; stop at doublequote.
       (let* ([idx (seekWhile (lambda (c)
                                (not (or (== c "\"")
                                         (== c "\\")))))])
         (if (== (Builtin.strlen string) idx)
             (Builtin.error "lex: unexpected newline in string")
             (let ([c (Builtin.slice string idx (+ idx 1))])
               (cond
                 [(== c "\"") (let* ([beforeQuote (Builtin.slice string 0 idx)]
                                     [afterQuote (Builtin.slice string (+ idx 1))]
                                     [s (strcat prefix beforeQuote)])
                                (Util.list (Str s) afterQuote))]
                 [(== c "\\") (Builtin.error "TODO interpret escapes")]
                 [else (Builtin.error (Util.list "no case in lexStringContents for" c))]))))))

  (= eatWhitespaceAndComments
     (lambda (string) ; -> string
       (if (== 0 (Builtin.strlen string))
           string
           (let ([c (Builtin.slice string 0 1)])
             (cond
               [(== c " ") (eatWhitespaceAndComments (Builtin.slice string 1))]
               [(== c "\t") (eatWhitespaceAndComments (Builtin.slice string 1))]
               [(== c "#") (let ([idx (seekWhile (lambda (c) (not (== "\n" c)))
                                                 string)])
                             (eatWhitespaceAndComments (Builtin.slice string idx)))]
               [else string]))))))

(module Parser
    #;()

  #|

  grammar:

  def := expr = expr

  parseExpr :
  .  peek:
  .   - if -> parse an if
  .   - fn -> parse a fn
  .   - open -> parse a subexpr
  .   - otherwise -> parseCall

  parseCall :
  .  - parseAtom
  .  peek:
  .   - if open paren: parse the args, then parseCall

  |#
  )

(module Loader
    #;()

  (= runModule
     (lambda (modname)
       (runModuleHelper modname '())))
  (= runModuleHelper
     (lambda (modname seen)
       (let ([_ (Builtin.debug (Util.list "runModuleHelper" modname seen))])
         (cond
           [(System.moduleExists modname) "already exists"]
           [(Util.contains seen modname) (Builtin.error (Util.list "cyclic module dependency:" seen))]
           [else
            ; interpret modname as a filename
            (let* ([text (System.readFile modname)]
                   [ast (System.parse text)]
                   [_ (verifyModule ast)]
                   [deps (Util.remove modname (scan ast))]
                   [_ (Builtin.debug (Util.list "deps for" modname "are" deps))]
                   [_ (let* ([seen (Builtin.link modname seen)]
                             [runModule (lambda (modname) (runModuleHelper modname seen))])
                        (Util.foreach runModule deps))]
                   [mod (System.eval ast)])
              (System.registerModule mod))]))))

  (= verifyModule
     (lambda (ast)
       (Util.cases
        ast
        ; unbound locals
        ; defs match the modname
        ; duplicate defs and params
        (Util.list
         (Util.list #'Syntax.Module
                    (lambda (modname statements)
                      ; get def LHSes:
                      (begin
                        (let* ([lhses (Util.map
                                       (lambda (stmt)
                                         (let ([unpacked (Syntax.unpack #'Syntax.Def stmt)])
                                           (if unpacked
                                               (Builtin.first unpacked)
                                               #false)))
                                       statements)]
                               [lhses (Util.filter (lambda (x) x) lhses)]
                               ; - check are all globals
                               [lhsNames
                                (Util.map
                                 (lambda (lhs)
                                   (Util.cases
                                    lhs
                                    (Util.list (Util.list #'Syntax.Global
                                                          (lambda (mod name)
                                                            ; - check modname matches
                                                            (if (Builtin.== mod modname)
                                                                name
                                                                (Builtin.error "def modname mismatch")))))))
                                 lhses)])
                          ; - check no dupes
                          (verifyDistinct lhsNames))
                        (let ([exprs (Util.map
                                      (lambda (stmt)
                                        (let ([unpacked (Syntax.unpack #'Syntax.Def stmt)])
                                          (if unpacked
                                              (Util.second unpacked)
                                              stmt)))
                                      statements)])
                          (Util.foreach (lambda (e) (verifyExpr e '())) exprs)))))))))
  (= verifyExpr
     (lambda (ast env) ; env : listof local
       (let ([r (lambda (ast) (verifyExpr ast env))])
         (Util.cases
          ast
          (Util.list
           (Util.list #'Syntax.Module (lambda (modname statements)
                                        (Builtin.error (Util.list "not an expression:" ast))))
           (Util.list #'Syntax.Using (lambda (modname)
                                       (Builtin.error (Util.list "not an expression:" ast))))
           (Util.list #'Syntax.Def (lambda (var expr)
                                     (Builtin.error (Util.list "not an expression:" ast))))
           (Util.list #'Syntax.Lit (lambda (value)
                                     ; TODO what kind of values can go in a literal?
                                     ;  - all values?
                                     ;  - only values that can be parsed?
                                     ;  - only atomic values?
                                     (Builtin.void)))
           (Util.list #'Syntax.Quote (lambda (subast)
                                       ; ??? check more?
                                       (Builtin.void)))
           (Util.list #'Syntax.Global (lambda (mod name)
                                        ; ??? check mod is not false?
                                        (Builtin.void)))
           (Util.list #'Syntax.Local (lambda (name number)
                                       (if (Util.contains env ast)
                                           (Builtin.void)
                                           (Builtin.error (Util.list "unbound local" ast)))))
           (Util.list #'Syntax.Func (lambda (params body)
                                      (let* ([names (Util.map getLocalName params)]
                                             [_ (verifyDistinct names)]
                                             [env (append params env)])
                                        (verifyExpr body env))))
           (Util.list #'Syntax.Call (lambda (func args)
                                      (begin
                                        (r func)
                                        (Util.foreach r args))))
           (Util.list #'Syntax.If (lambda (test consq alt)
                                    (begin
                                      (r test)
                                      (r consq)
                                      (r alt)))))))))
  (= getLocalName
     (lambda (param)
       (Util.cases param
                   (Util.list (Util.list #'Syntax.Local
                                         (lambda (name num) name))))))
  (= verifyDistinct
     (lambda (names)
       (cond
         [(Builtin.isEmpty names) (Builtin.void)]
         [(Util.contains (Builtin.rest names)
                         (Builtin.first names)) (Builtin.error (Util.list "duplicate name:" (first names)))]
         [else (verifyDistinct (Builtin.rest names))])))



  (= scan
     (lambda (ast) ; -> list of
       (Util.cases
        ast
        (Util.list
         (Util.list #'Syntax.Global (lambda (mod name) (Util.list mod)))
         (Util.list #'Syntax.Module (lambda (modname statements) (scanMany statements)))
         (Util.list #'Syntax.Using (lambda (modname) (Util.list)))
         (Util.list #'Syntax.Def (lambda (var expr) (scan expr)))
         (Util.list #'Syntax.Lit (lambda (value) (Util.list)))
         (Util.list #'Syntax.Quote (lambda (subast) (scan subast)))
         (Util.list #'Syntax.Local (lambda (name number) (Util.list)))
         (Util.list #'Syntax.Func (lambda (params body) (scan body)))
         (Util.list #'Syntax.Call (lambda (func args) (scanMany (Builtin.link func args))))
         (Util.list #'Syntax.If (lambda (test consq alt) (scanMany (Util.list test consq alt))))))))
  (= scanMany
     (lambda (asts)
       (Builtin.apply Util.append (Util.map scan asts)))))

(let ([args (System.getArgs)])
  (if (Builtin.isEmpty args)
      (Builtin.error "specify a main module")
      (Loader.runModule (Builtin.first args))))
