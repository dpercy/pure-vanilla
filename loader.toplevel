(module Util
    #;()
  (= map
     (lambda (f lst)
       (if (Builtin.isEmpty lst)
           '()
           (Builtin.link (f (Builtin.first lst))
                         (map f (Builtin.rest lst))))))
  (= foreach
     (lambda (f lst)
       (if (Builtin.isEmpty lst)
           (Builtin.void)
           (begin (f (Builtin.first lst))
                  (foreach f (Builtin.rest lst))))))

  (= second
     (lambda (v) (Builtin.first (Builtin.rest v))))

  (= not (lambda (v) (if v #false #true)))

  (= list (Builtin.makeVariadic (lambda (lst) lst)))

  (= cases
     (lambda (ast handlers)
       (if (Builtin.isEmpty handlers)
           (Builtin.error (list "no case for ast" ast))
           (let* ([tag (Builtin.first (Builtin.first handlers))]
                  [handler (second (Builtin.first handlers))]
                  [unpacked (Syntax.unpack tag ast)])
             (if unpacked
                 (Builtin.apply handler unpacked)
                 (cases ast (Builtin.rest handlers)))))))
  (= hasTag (lambda (v tag)
              (not (Builtin.== #false (Syntax.unpack tag v)))))

  (= foldr (lambda (f base lst)
             (if (Builtin.isEmpty lst)
                 base
                 (f (Builtin.first lst)
                    (foldr f base (Builtin.rest lst))))))

  (= append2 (lambda (a b) (foldr Builtin.link b a)))
  (= append (Builtin.makeVariadic (lambda (lists) (foldr append2 '() lists))))

  (= filter (lambda (pred lst)
              (if (Builtin.isEmpty lst)
                  '()
                  (if (pred (Builtin.first lst))
                      (Builtin.link (Builtin.first lst) (filter pred (Builtin.rest lst)))
                      (filter pred (Builtin.rest lst))))))

  (= remove (lambda (elem lst)
              (filter (lambda (x) (if (Builtin.== elem x) #false #true)) lst)))

  (= any (lambda (pred lst)
           (cond
             [(Builtin.isEmpty lst) #false]
             [(pred (Builtin.first lst)) #true]
             [else (any pred (Builtin.rest lst))])))

  (= contains (lambda (lst elem)
                (any (lambda (x) (Builtin.== x elem)) lst))))

(module Loader
    #;()

  (= list Util.list)

  (= runModule
     (lambda (modname)
       (runModuleHelper modname '())))
  (= runModuleHelper
     (lambda (modname seen)
       (let ([_ (Builtin.debug (list "runModuleHelper" modname seen))])
         (cond
           [(System.moduleExists modname) "already exists"]
           [(Util.contains seen modname) (Builtin.error (list "cyclic module dependency:" seen))]
           [else
            ; interpret modname as a filename
            (let* ([text (System.readFile modname)]
                   [ast (System.parse text)]
                   [_ (verifyModule ast)]
                   [deps (Util.remove modname (scan ast))]
                   [_ (Builtin.debug (list "deps for" modname "are" deps))]
                   [_ (let* ([seen (Builtin.link modname seen)]
                             [runModule (lambda (modname) (runModuleHelper modname seen))])
                        (Util.foreach runModule deps))]
                   [mod (System.eval ast)])
              (System.registerModule mod))]))))

  (= verifyModule
     (lambda (ast)
       (Util.cases
        ast
        ; unbound locals
        ; defs match the modname
        ; duplicate defs and params
        (list
         (list #'Syntax.Module
               (lambda (modname statements)
                 ; get def LHSes:
                 (begin
                   (let* ([lhses (Util.map
                                  (lambda (stmt)
                                    (let ([unpacked (Syntax.unpack #'Syntax.Def stmt)])
                                      (if unpacked
                                          (Builtin.first unpacked)
                                          #false)))
                                  statements)]
                          [lhses (Util.filter (lambda (x) x) lhses)]
                          ; - check are all globals
                          [lhsNames
                           (Util.map
                            (lambda (lhs)
                              (Util.cases
                               lhs
                               (list (list #'Syntax.Global
                                           (lambda (mod name)
                                             ; - check modname matches
                                             (if (Builtin.== mod modname)
                                                 name
                                                 (error "def modname mismatch")))))))
                            lhses)])
                     ; - check no dupes
                     (verifyDistinct lhsNames))
                   (let ([exprs (Util.map
                                 (lambda (stmt)
                                   (let ([unpacked (Syntax.unpack #'Syntax.Def stmt)])
                                     (if unpacked
                                         (Util.second unpacked)
                                         stmt)))
                                 statements)])
                     (Util.foreach (lambda (e) (verifyExpr e '())) exprs)))))))))
  (= verifyExpr
     (lambda (ast env) ; env : listof local
       (let ([r (lambda (ast) (verifyExpr ast env))])
         (Util.cases
          ast
          (list
           (list #'Syntax.Module (lambda (modname statements)
                                   (Builtin.error (list "not an expression:" ast))))
           (list #'Syntax.Using (lambda (modname)
                                  (Builtin.error (list "not an expression:" ast))))
           (list #'Syntax.Def (lambda (var expr)
                                (Builtin.error (list "not an expression:" ast))))
           (list #'Syntax.Lit (lambda (value)
                                ; TODO what kind of values can go in a literal?
                                ;  - all values?
                                ;  - only values that can be parsed?
                                ;  - only atomic values?
                                (Builtin.void)))
           (list #'Syntax.Quote (lambda (subast)
                                  ; ??? check more?
                                  (Builtin.void)))
           (list #'Syntax.Global (lambda (mod name)
                                   ; ??? check mod is not false?
                                   (Builtin.void)))
           (list #'Syntax.Local (lambda (name number)
                                  (if (Util.contains env ast)
                                      (Builtin.void)
                                      (Builtin.error (list "unbound local" ast)))))
           (list #'Syntax.Func (lambda (params body)
                                 (let* ([names (Util.map getLocalName params)]
                                        [_ (verifyDistinct names)]
                                        [env (append params env)])
                                   (verifyExpr body env))))
           (list #'Syntax.Call (lambda (func args)
                                 (begin
                                   (r func)
                                   (Util.foreach r args))))
           (list #'Syntax.If (lambda (test consq alt)
                               (begin
                                 (r test)
                                 (r consq)
                                 (r alt)))))))))
  (= getLocalName
     (lambda (param)
       (Util.cases param
                   (list (list #'Syntax.Local
                               (lambda (name num) name))))))
  (= verifyDistinct
     (lambda (names)
       (cond
         [(Builtin.isEmpty names) (Builtin.void)]
         [(Util.contains (Builtin.rest names)
                         (Builtin.first names)) (Builtin.error (list "duplicate name:" (first names)))]
         [else (verifyDistinct (Builtin.rest names))])))



  (= scan
     (lambda (ast) ; -> list of
       (Util.cases
        ast
        (list
         (list #'Syntax.Global (lambda (mod name) (list mod)))
         (list #'Syntax.Module (lambda (modname statements) (scanMany statements)))
         (list #'Syntax.Using (lambda (modname) (list)))
         (list #'Syntax.Def (lambda (var expr) (scan expr)))
         (list #'Syntax.Lit (lambda (value) (list)))
         (list #'Syntax.Quote (lambda (subast) (scan subast)))
         (list #'Syntax.Local (lambda (name number) (list)))
         (list #'Syntax.Func (lambda (params body) (scan body)))
         (list #'Syntax.Call (lambda (func args) (scanMany (Builtin.link func args))))
         (list #'Syntax.If (lambda (test consq alt) (scanMany (list test consq alt))))))))
  (= scanMany
     (lambda (asts)
       (Builtin.apply Util.append (Util.map scan asts)))))

(let ([args (System.getArgs)])
  (if (Builtin.isEmpty args)
      (Builtin.error "specify a main module")
      (Loader.runModule (Builtin.first args))))
