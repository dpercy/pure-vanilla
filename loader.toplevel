(module Util
    #;()
  (= map
     (lambda (f lst)
       (if (Builtin.isEmpty lst)
           '()
           (Builtin.link (f (Builtin.first lst))
                         (map f (Builtin.rest lst))))))
  (= foreach
     (lambda (f lst)
       (if (Builtin.isEmpty lst)
           (Builtin.void)
           (begin (f (Builtin.first lst))
                  (foreach f (Builtin.rest lst))))))

  (= second
     (lambda (v) (Builtin.first (Builtin.rest v))))

  (= not (lambda (v) (if v #false #true)))

  (= list (Builtin.makeVariadic (lambda (lst) lst)))

  (= cases
     (lambda (ast handlers)
       (if (Builtin.isEmpty handlers)
           (Builtin.error (list "no case for ast" ast))
           (let* ([tag (Builtin.first (Builtin.first handlers))]
                  [handler (second (Builtin.first handlers))]
                  [unpacked (Syntax.unpack tag ast)])
             (if unpacked
                 (Builtin.apply handler unpacked)
                 (cases ast (Builtin.rest handlers)))))))
  (= hasTag (lambda (v tag)
              (not (Builtin.== #false (Syntax.unpack tag v)))))

  (= foldr (lambda (f base lst)
             (if (Builtin.isEmpty lst)
                 base
                 (f (Builtin.first lst)
                    (foldr f base (Builtin.rest lst))))))

  (= append2 (lambda (a b) (foldr Builtin.link b a)))
  (= append (Builtin.makeVariadic (lambda (lists) (foldr append2 '() lists))))

  (= filter (lambda (pred lst)
              (if (Builtin.isEmpty lst)
                  '()
                  (if (pred (Builtin.first lst))
                      (Builtin.link (Builtin.first lst) (filter pred (Builtin.rest lst)))
                      (filter pred (Builtin.rest lst))))))

  (= remove (lambda (elem lst)
              (filter (lambda (x) (if (Builtin.== elem x) #false #true)) lst)))

  (= any (lambda (pred lst)
           (cond
             [(Builtin.isEmpty lst) #false]
             [(pred (Builtin.first lst)) #true]
             [else (any pred (Builtin.rest lst))])))

  (= contains (lambda (lst elem)
                (any (lambda (x) (Builtin.== x elem)) lst)))

  (= explode (lambda (string)
               (if (== (strlen string) 0)
                   '()
                   (cons (slice string 0 1)
                         (explode (slice string 1)))))))

(module Lexer
    #;()

  #|

  delimiters:
  ()[]{},;

  TODO add qualified idens and ops
  - no space allowed around dot - dot is not a separate token

  iden := ( alpha | "_" ) ( alpha | digit | "_" )*

  num := digit+

  op := symbol+
  where symbol is any non-alpha, non-digit, non-whitespace, non-comment-start, non-delimiter

  string := doublequote ( nonquotenonbackslash | escapesequence )* doublequote

  - fixed tokens are represented by strings: "eof", "(", "\n", etc


  |#

  (= Iden #'Iden) ; holds the iden as a string, like "myIden123"
  (= Op #'Op) ; holds the iden as a string, like "<"
  (= Num #'Num) ; holds the number as a string, like "123"
  (= Str #'Str) ; holds the *value* of the string, like "\t"; NOT "\"\\t\""

  (= ord Builtin.ord)
  (= < Builtin.<)
  (= == Builtin.==)

  (= delimiters (explode "()[]{},;\n"))
  (= isDelimiter (lambda (c) (Builtin.contains delimiters c)))

  (= ops (explode "~!@$%^&*_-+=:<>/?"))
  (= isOp (lambda (c) (Builtin.contains ops c)))

  (= isDigit (lambda (c) (and (<= (ord "0") (ord c)) (<= (ord c) (ord "9")))))
  (= isLower (lambda (c) (and (<= (ord "a") (ord c)) (<= (ord c) (ord "z")))))
  (= isUpper (lambda (c) (and (<= (ord "A") (ord c)) (<= (ord c) (ord "Z")))))
  (= isAlpha (lambda (c) (or (isLower c) (isUpper c))))

  (= isIdenStart (lambda (c) (or (== "_" c) (isAlpha c))))
  (= isIden (lambda (c) (or (isIdentStart c) (isDigit c))))

  (= lexAll
     (lambda (string) ; -> listof token
       (let* ([tokAndRest (lex string)]
              [tok (Builtin.first string)]
              [rest (Util.second string)])
         (if (== tok "eof")
             '()
             (Builtin.cons tok (lexAll rest))))))

  (= seekWhile
     (lambda (pred string) ; index
       ; return the first index in the string that fails the predicate
       (seekWhileLoop pred string 0)))
  (= seekWhileLoop
     (lambda (pred string idx) ; index
       (if (== idx (strlen string))
           idx
           (let ([c (slice string idx (+ idx 1))])
             (if (pred c)
                 (seekWhileLoop pred string (+ idx 1))
                 idx)))))

  ; TODO may need to trampoline this on implementations with small stacks:
  ;  - add a function Builtin.trampoline
  (= lex
     (lambda (string) ; -> [token-or-eof, string]
       (let ([string (eatWhitespaceAndComments string)])
         (if (== 0 (strlen string))
             (list "eof" string)
             (let ([c (slice string 0 1)])
               (cond
                 [(isDelimiter c) (list c (slice string 1))]
                 [(isIdenStart c) (lexIden string)]
                 [(isDigit c) (lexNumber string)]
                 [(isOp c) (lexOp string)]
                 [(== c "\"") (lexStringContents (slice string 1))]
                 [else (Builtin.error (list "lex: unexpected character:" c))]))))))

  (= keywords (list "if" "then" "else"
                    "fn" "->"))
  (= isKeyword (lambda (s) (Builtin.contains keywords s)))

  (= lexIden
     (lambda (string)
       (let* ([idx (seekWhile isIden string)]
              [prefix (slice string 0 idx)]
              [suffix (slice string idx)]
              [tok (if (isKeyword prefix)
                       prefix
                       (Iden prefix))])
         (list tok suffix))))

  (= lexNumber
     (lambda (string)
       (let* ([idx (seekWhile isIden string)]
              [prefix (slice string 0 idx)]
              [suffix (slice string idx)]
              [tok (Num prefix)])
         ; leave the number as a string because the toplevel implementation
         ; might not support very wide integers
         (list tok suffix))))

  (= lexOp
     (lambda (string)
       (let* ([idx (seekWhile isOp string)]
              [prefix (slice string 0 idx)]
              [suffix (slice string idx)]
              [tok (if (isKeyword prefix)
                       prefix
                       (Op prefix))])
         (list tok suffix))))

  (= lexStringContents
     (lambda (string)
       ; TODO get characters one by one, interpreting escapes; stop at doublequote.
       ))

  (= eatWhitespaceAndComments
     (lambda (string) ; -> string
       (if (== 0 (strlen string))
           string
           (let ([c (slice string 0 1)])
             (cond
               [(== c " ") (eatWhitespaceAndComments (slice string 1))]
               [(== c "\t") (eatWhitespaceAndComments (slice string 1))]
               [(== c "#") (let ([idx (seekWhile (lambda (c) (not (== "\n" c)))
                                                 string)])
                             (eatWhitespaceAndComments (slice string idx)))]))))))

(module Parser
    #;()

  #|

  grammar:

  def := expr = expr

  parseExpr :
  .  peek:
  .   - if -> parse an if
  .   - fn -> parse a fn
  .   - open -> parse a subexpr
  .   - otherwise -> parseCall

  parseCall :
  .  - parseAtom
  .  peek:
  .   - if open paren: parse the args, then parseCall

  |#
  )

(module Loader
    #;()

  (= list Util.list)

  (= runModule
     (lambda (modname)
       (runModuleHelper modname '())))
  (= runModuleHelper
     (lambda (modname seen)
       (let ([_ (Builtin.debug (list "runModuleHelper" modname seen))])
         (cond
           [(System.moduleExists modname) "already exists"]
           [(Util.contains seen modname) (Builtin.error (list "cyclic module dependency:" seen))]
           [else
            ; interpret modname as a filename
            (let* ([text (System.readFile modname)]
                   [ast (System.parse text)]
                   [_ (verifyModule ast)]
                   [deps (Util.remove modname (scan ast))]
                   [_ (Builtin.debug (list "deps for" modname "are" deps))]
                   [_ (let* ([seen (Builtin.link modname seen)]
                             [runModule (lambda (modname) (runModuleHelper modname seen))])
                        (Util.foreach runModule deps))]
                   [mod (System.eval ast)])
              (System.registerModule mod))]))))

  (= verifyModule
     (lambda (ast)
       (Util.cases
        ast
        ; unbound locals
        ; defs match the modname
        ; duplicate defs and params
        (list
         (list #'Syntax.Module
               (lambda (modname statements)
                 ; get def LHSes:
                 (begin
                   (let* ([lhses (Util.map
                                  (lambda (stmt)
                                    (let ([unpacked (Syntax.unpack #'Syntax.Def stmt)])
                                      (if unpacked
                                          (Builtin.first unpacked)
                                          #false)))
                                  statements)]
                          [lhses (Util.filter (lambda (x) x) lhses)]
                          ; - check are all globals
                          [lhsNames
                           (Util.map
                            (lambda (lhs)
                              (Util.cases
                               lhs
                               (list (list #'Syntax.Global
                                           (lambda (mod name)
                                             ; - check modname matches
                                             (if (Builtin.== mod modname)
                                                 name
                                                 (error "def modname mismatch")))))))
                            lhses)])
                     ; - check no dupes
                     (verifyDistinct lhsNames))
                   (let ([exprs (Util.map
                                 (lambda (stmt)
                                   (let ([unpacked (Syntax.unpack #'Syntax.Def stmt)])
                                     (if unpacked
                                         (Util.second unpacked)
                                         stmt)))
                                 statements)])
                     (Util.foreach (lambda (e) (verifyExpr e '())) exprs)))))))))
  (= verifyExpr
     (lambda (ast env) ; env : listof local
       (let ([r (lambda (ast) (verifyExpr ast env))])
         (Util.cases
          ast
          (list
           (list #'Syntax.Module (lambda (modname statements)
                                   (Builtin.error (list "not an expression:" ast))))
           (list #'Syntax.Using (lambda (modname)
                                  (Builtin.error (list "not an expression:" ast))))
           (list #'Syntax.Def (lambda (var expr)
                                (Builtin.error (list "not an expression:" ast))))
           (list #'Syntax.Lit (lambda (value)
                                ; TODO what kind of values can go in a literal?
                                ;  - all values?
                                ;  - only values that can be parsed?
                                ;  - only atomic values?
                                (Builtin.void)))
           (list #'Syntax.Quote (lambda (subast)
                                  ; ??? check more?
                                  (Builtin.void)))
           (list #'Syntax.Global (lambda (mod name)
                                   ; ??? check mod is not false?
                                   (Builtin.void)))
           (list #'Syntax.Local (lambda (name number)
                                  (if (Util.contains env ast)
                                      (Builtin.void)
                                      (Builtin.error (list "unbound local" ast)))))
           (list #'Syntax.Func (lambda (params body)
                                 (let* ([names (Util.map getLocalName params)]
                                        [_ (verifyDistinct names)]
                                        [env (append params env)])
                                   (verifyExpr body env))))
           (list #'Syntax.Call (lambda (func args)
                                 (begin
                                   (r func)
                                   (Util.foreach r args))))
           (list #'Syntax.If (lambda (test consq alt)
                               (begin
                                 (r test)
                                 (r consq)
                                 (r alt)))))))))
  (= getLocalName
     (lambda (param)
       (Util.cases param
                   (list (list #'Syntax.Local
                               (lambda (name num) name))))))
  (= verifyDistinct
     (lambda (names)
       (cond
         [(Builtin.isEmpty names) (Builtin.void)]
         [(Util.contains (Builtin.rest names)
                         (Builtin.first names)) (Builtin.error (list "duplicate name:" (first names)))]
         [else (verifyDistinct (Builtin.rest names))])))



  (= scan
     (lambda (ast) ; -> list of
       (Util.cases
        ast
        (list
         (list #'Syntax.Global (lambda (mod name) (list mod)))
         (list #'Syntax.Module (lambda (modname statements) (scanMany statements)))
         (list #'Syntax.Using (lambda (modname) (list)))
         (list #'Syntax.Def (lambda (var expr) (scan expr)))
         (list #'Syntax.Lit (lambda (value) (list)))
         (list #'Syntax.Quote (lambda (subast) (scan subast)))
         (list #'Syntax.Local (lambda (name number) (list)))
         (list #'Syntax.Func (lambda (params body) (scan body)))
         (list #'Syntax.Call (lambda (func args) (scanMany (Builtin.link func args))))
         (list #'Syntax.If (lambda (test consq alt) (scanMany (list test consq alt))))))))
  (= scanMany
     (lambda (asts)
       (Builtin.apply Util.append (Util.map scan asts)))))

(let ([args (System.getArgs)])
  (if (Builtin.isEmpty args)
      (Builtin.error "specify a main module")
      (Loader.runModule (Builtin.first args))))
