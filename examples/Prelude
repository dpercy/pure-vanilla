# TODO implement actual parsing for boolean literals...
true = 1 == 1
false = 1 == 0

# hacky non-short-circuiting boolean operators
and = (a, b) -> if a then b else false
or = (a, b) -> if a then a else b
all = (pred, lst) -> foldl(and, true, map(pred, lst))

# normal boolean functions
not = (x) -> if x then false else true


# list functions

cons = (hd, tl) -> [hd, ...tl]

elem = (x, lst) ->
  if isEmpty(lst) then false
  else if x == first(lst) then true
  else elem(x, rest(lst))

append = (a, b) ->
  if isEmpty(a) then b
  else cons(first(a), append(rest(a), b))

replicate = (n, x) ->
  if 0 < n then cons(x, replicate(n - 1, x))
  else []

take = (n, lst) ->
  if isEmpty(lst) then []
  else if n == 0 then []
  # TODO use >
  else if 0 < n then cons(first(lst), take(n - 1, rest(lst)))
  else error("take negative")

drop = (n, lst) ->
  if isEmpty(lst) then []
  else if n == 0 then lst
  # TODO use >
  else if 0 < n then drop(n - 1, rest(lst))
  else error("drop negative")

chunk = (n, lst) ->
  if isEmpty(lst) then []
  else cons(take(n, lst), chunk(n, drop(n, lst)))

transpose = (lsts) ->
  if all(isEmpty, lsts) then []
  else if all(compose(not, isEmpty), lsts) then cons(map(first, lsts),
                                                     transpose(map(rest, lsts)))
  else error("transpose ragged lists")


# higher-order list functions

map = (f, lst) ->
  if isEmpty(lst) then []
  else [ f(first(lst)), ...map(f, rest(lst)) ]

foldl = (f, init, lst) ->
  if isEmpty(lst) then init
  else foldl(f, f(init, first(lst)), rest(lst))

foldr = (f, init, lst) ->
  if isEmpty(lst) then init
  else f(first(lst), foldr(f, init, rest(lst)))

filter = (f, lst) ->
  if isEmpty(lst) then lst
  else if f(first(lst)) then cons(first(lst),
                                  filter(f, rest(lst)))
  else filter(f, rest(lst))


# function functions

compose = (f, g) -> (x) -> f(g(x))


# number functions

abs = (n) -> 
  if n < 0
  then (- n)
  else n

# TODO allow defining operators (>) = (x, y) -> (y < x)


# sorting


sort = insertionSort

insertionSort = (lst) -> foldr(insertionSortInsert, [], lst)
insertionSortInsert = (e, lst) ->
  if isEmpty(lst) then [e]
  else if e < first(lst) then cons(e, lst)
  else cons(first(lst), insertionSortInsert(e, rest(lst)))
