#lang vanilla

# testing
assert = makeVariadic((args) ->
                      let f = first(args) in
                      let a = rest(args) in
                      let v = apply(f, a) in
                      if v then "ok" else error(strcat("assertion fail: ", show(f), show(a))))
# test that unqualified ids in Prelude resolve to Prelude ids
assert(==, show(:assert), show(:Prelude.assert))
# test that == works on the raw syntax objects
assert(==, :assert, :Prelude.assert)
# but === still distinguishes them
assert(!==, :assert, :Prelude.assert)

# TODO fix control flow on these
# hacky non-short-circuiting boolean operators
and = (a, b) -> if a then b else false
or = (a, b) -> if a then a else b
all = (pred, lst) -> foldl(and, true, map(pred, lst))

# normal boolean functions
not = (x) -> if x then false else true


# list functions

elem = (x, lst) ->
  if isEmpty(lst) then false
  else if x == first(lst) then true
  else elem(x, rest(lst))

append = (a, b) ->
# TODO replace with foldr(cons, b, a) ?
  if isEmpty(a) then b
  else cons(first(a), append(rest(a), b))

concat = (lists) -> foldr(append, [], lists)
assert(==, concat([[1,2], [], [3,4,5]]), [1,2,3,4,5])

reverse = (lst) -> foldl(flip(cons), [], lst)

replicate = (n, x) ->
  if 0 < n then cons(x, replicate(n - 1, x))
  else []

take = (n, lst) ->
  if isEmpty(lst) then []
  else if n == 0 then []
  else if n > 0 then cons(first(lst), take(n - 1, rest(lst)))
else error("take negative")

drop = (n, lst) ->
  if isEmpty(lst) then []
  else if n == 0 then lst
  else if n > 0 then drop(n - 1, rest(lst))
  else error("drop negative")

chunk = (n, lst) ->
  if isEmpty(lst) then []
  else cons(take(n, lst), chunk(n, drop(n, lst)))

transpose = (lsts) ->
  if all(isEmpty, lsts) then []
  else if all(compose(not, isEmpty), lsts) then cons(map(first, lsts),
                                                     transpose(map(rest, lsts)))
  else error("transpose ragged lists")

takeWhile = (pred, lst) ->
  if isEmpty(lst) then []
  else if pred(first(lst))
   then cons(first(lst), takeWhile(pred, rest(lst)))
  else []

dropWhile = (pred, lst) ->
  if isEmpty(lst) then []
  else if pred(first(lst))
   then dropWhile(pred, rest(lst))
  else lst


# higher-order list functions

map = (f, lst) ->
  if isEmpty(lst) then []
  else cons(f(first(lst)), map(f, rest(lst)))

foldl = (f, init, lst) ->
  if isEmpty(lst) then init
  else foldl(f, f(init, first(lst)), rest(lst))

foldr = (f, init, lst) ->
  if isEmpty(lst) then init
  else f(first(lst), foldr(f, init, rest(lst)))

filter = (f, lst) ->
  if isEmpty(lst) then lst
  else if f(first(lst)) then cons(first(lst),
                                  filter(f, rest(lst)))
  else filter(f, rest(lst))


# function functions


compose = (f, g) -> (x) -> f(g(x))

flip = (f) -> (x, y) -> f(y, x)

id = (x) -> x


# number functions

abs = (n) ->
  if n < 0
  then (- n)
  else n

(>) = flip((<))

# TODO parameter and argument splats, so compose can be generic
# (<=) = compose(not, (>))
# (>=) = compose(not, (<))
(<=) = (x, y) -> not(x > y)
(>=) = (x, y) -> not(x < y)


# lists of numbers

sort = (lst) -> sortBy(id, lst)

sortBy = insertionSortBy

insertionSortBy = (key, lst) ->
  foldr((e, lst) -> insertionSortInsert(key, e, lst), [], lst)

insertionSortInsert = (key, e, lst) ->
  if isEmpty(lst) then [e]
  # careful with comparison, to make the sort stable.
  else if key(e) <= key(first(lst)) then cons(e, lst)
  else cons(first(lst), insertionSortInsert(key, e, rest(lst)))


sumBy = (key, lst) ->
  foldr((+), 0, map(key, lst))


# strings

splitchars = (str) ->
  # first(split(_, "")) is always "", so drop it.
  rest(split(str, ""))

