# TODO implement actual parsing for boolean literals...
true = 1 == 1
false = 1 == 0

# hacky non-short-circuiting boolean operators
and = (a, b) -> if a then b else false
or = (a, b) -> if a then a else b


# list functions

cons = (hd, tl) -> [hd, ...tl]

elem = (x, lst) ->
  if isEmpty(lst) then false
  else if x == first(lst) then true
  else elem(x, rest(lst))

append = (a, b) ->
  if isEmpty(a) then b
  else cons(first(a), append(rest(a), b))

replicate = (n, x) ->
  if 0 < n then cons(x, replicate(n - 1, x))
  else []


# higher-order list functions

map = (f, lst) ->
  if isEmpty(lst) then []
  else [ f(first(lst)), ...map(f, rest(lst)) ]

foldl = (f, init, lst) ->
  if isEmpty(lst) then init
  else foldl(f, f(init, first(lst)), rest(lst))

filter = (f, lst) ->
  if isEmpty(lst) then lst
  else if f(first(lst)) then cons(first(lst),
                                  filter(f, rest(lst)))
  else filter(f, rest(lst))



# number functions

abs = (n) -> 
  if n < 0
  then (- n)
  else n

