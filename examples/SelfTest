#lang vanilla

using Prelude
using Syntax

example = "this string is an example"
hungry = makeVariadic(args -> hungry)


# equality on atomic types
# - on booleans
assert(==, true, true)
assert(==, false, false)
assert(!=, false, true)
assert(!=, true, false)
# - on numbers
assert(==, 5, 5)
assert(!=, 5, 7)
# - on strings
assert(==, "red", "red")
assert(==, "blue", "blue")
assert(!=, "red", "blue")
assert(!=, "blue", "red")
# - on mixed types
assert(!=, 123, "123")
assert(!=, true, "true")
assert(!=, 0, false)
assert(!=, 1, true)
assert(!=, -1, true)


# booleans
assert(==, if true then "red" else "blue", "red")
assert(==, if false then "red" else "blue", "blue")
assert(==, show(true), "Base.true")
assert(==, show(false), "Base.false")


# numbers
half = 1 / 2
assert(isNumber, 3)
assert(isNumber, -4)
assert(isNumber, 0)
assert(isNumber, half)
# TODO what happens with division by zero?
assert(==, numerator(3), 3)
assert(==, denominator(3), 1)
assert(==, numerator(half), 1)
assert(==, denominator(half), 2)
assert(==, 3/12, 1/4)
assert(==, numerator(3/12), 1)
assert(==, denominator(3/12), 4)
assert(==, numerator(5 + half), 11)
assert(==, denominator(5 + half), 2)
assert(<, 0, 1)
assert(<, 0, 57)
assert(<, -57, 0)
assert(<, 2/5, 4/9)
assert(<, -(4/9), -(2/5))
assert(==, show(5), "5")
assert(==, show(-6), "-6")
assert(==, show(1/3), "1/3")
assert(==, show(-(4/9)), "-4/9")


# strings
assert(isString, "")
assert(isString, " ")
assert(isString, "!")
assert(isString, example)
assert(==, slice("", 0, 0), "")
assert(==, slice("asdf", 0, 0), "")
assert(==, slice("asdf", 0, 2), "as")
assert(==, slice("asdf", 0, 4), "asdf")
assert(==, slice("asdf", 2, 4), "df")
assert(==, parseInt("123"), 123)
assert(==, length(""), 0)
assert(==, length("asdf"), 4)
assert(==, length("0123456789abcdef"), 16)
assert(==, strcat(), "")
assert(==, strcat("a", "b"), "ab")
assert(==, strcat("a", "b", "c"), "abc")
assert(==, show("asdf"), "\"asdf\"")



# lists
assert(==, [], [])
assert(isEmpty, [])
assert(isPair, [1])
assert(isPair, [1, 2])
assert(==, [1, 2, 3], [1, 2, 3])
assert(==, ["foo", 7], ["foo", 7])
assert(==, first(["foo", 7]), "foo")
assert(==, rest(["foo", 7]), [7])
assert(==, show([123, "asdf", true]), "[123, \"asdf\", Base.true]")



# functions
assert(isFunc, assert)
assert(isFunc, list)
assert(isFunc, first)
assert(isFunc, rest)
assert(isFunc, error)
assert(isFunc, x -> 2 + x)
assert(==, show(+), "(Base.+)")
assert(==, show(error), "Base.error")
assert(==, show(x -> 2 + x),                "(x.0) -> (Base.+)(2, x.0)")
assert(==, show((x.0) -> (Base.+)(2, x.0)), "(x.0) -> (Base.+)(2, x.0)")


# syntax
assert(isSyntax, :x)
assert(isSyntax, :Prelude.assert)
assert(isSyntax, :(5))
assert(isSyntax, :(if 123 then f() else 2 + "seven"))
# - unqualified ids in a module resolve to that module's ids
assert(==, show(:example), show(:SelfTest.example))
# - raw syntax objects compare ==
assert(==, :assert, :Prelude.assert)
assert(==, :example, :SelfTest.example)
# - but === still distinguishes them, because the source loc makes them observably different.
assert(!==, :assert, :Prelude.assert)
assert(!==, :example, :SelfTest.example)

# - equality on literals
assert(==, :(1), :(1))
assert(!=, :(1), :(2))

assert(==, pack(:Lit, 55), :(55))
assert(==, pack(:Lit, "whee"), :("whee"))

assert(==, pack(:Global, "Prelude", "assert"), :Prelude.assert)
assert(==, unpack(:Global, :Prelude.assert), ["Prelude", "assert"])
assert(==, unpack(:If, :Prelude.assert), false)

assert(==, pack(:If, :(1), :(2), :(3)), :(if 1 then 2 else 3))
assert(!=, pack(:If, :(1), :(2), :(4)), :(if 1 then 2 else 3))
### assert(==, unpack(:If, :(if 1 then 2 else 3)), [:(1), :(2), :(3)])
wat = unpack(:If, :(if 1 then 2 else 3))

assert(==, unpack(:Quote, :(:(527))), [:(527)])
assert(==, unpack(:Local, :x.14), ["x", 14])
assert(==, unpack(:Func, :(x -> x)), [[:x.0], :x.0])

assert(==, unpack(:Call, :(f(1))), [:f, [:(1)]])

assert(==, unpack(:Global, :SelfTest.no_such_definition), ["SelfTest", "no_such_definition"])
# TODO make unbound globals resolve to current module?
## assert(==, unpack(:Global, :no_such_definition), ["SelfTest", "no_such_definition"])
## assert(==, show(:asdf), ":SelfTest.asdf")


# function inspection: functions + syntax
assert(==, inspect(x -> x), :(x -> x))