
# TODO this should evaluate to [2, 0] but I get [3, 0]
example = guardStep(isValid_part1)([2, 0], "R")

main = (input) -> pretty(eval(initialState, isValid_part1, parse(input)))

parse = (input) -> map(parseLine, splitlines(input))
parseLine = (line) -> filter(nonempty, split(line, ""))
nonempty = (s) -> 0 < length(s)

initialState = [1, 1] # x across, y down

guardStep = (isValid) -> (state, letter) ->
  let newState = step(state, letter) in
  if isValid(newState) then newState
  else state
isValid_part1 = (state) ->
  let x = first(state) in
  let y = first(rest(state)) in
  foldl(and, true, [ (-1) < x, x < 3,
                     (-1) < y, y < 3, ])

step = (state, letter) ->
  let x = first(state) in
  let y = first(rest(state)) in
  if      letter == "U" then [x, dec(y)]
  else if letter == "D" then [x, inc(y)]
  else if letter == "L" then [dec(x), y]
  else if letter == "R" then [inc(x), y]
  else error("bad letter")
inc = (n) -> n + 1
dec = (n) -> n - 1

eval = (state, isValid, lines) ->
  if isEmpty(lines) then []
  else let newState = evalLine(state, isValid, first(lines)) in
         cons(newState, eval(newState, isValid, rest(lines)))

evalLine = (state, isValid, line) -> foldl(guardStep(isValid), state, line)

pretty = (states) -> foldl((a, b) -> strcat(a, b), "", map(prettyState, states))
prettyState = (state) ->
  let x = first(state) in
  let y = first(rest(state)) in
  show((y * 3) + x + 1)


# TODO stdlib
map = (f, lst) ->
  if isEmpty(lst) then lst
  else cons(f(first(lst)), map(f, rest(lst)))
filter = (f, lst) ->
  if isEmpty(lst) then lst
  else if f(first(lst)) then cons(first(lst), filter(f, rest(lst)))
  else filter(f, rest(lst))

foldl = (f, init, lst) ->
  if isEmpty(lst) then init
  else foldl(f, f(init, first(lst)), rest(lst))

cons = (head, tail) -> [head, ...tail]

true = 0 == 0
false = 0 < 0
and = (a, b) -> if a then b else false
