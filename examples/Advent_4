main = (input) ->
  # What is the sum of the sector IDs of the real rooms?
  show(sumBy(roomId, filter(isRoomReal, parseRooms(input))))

parseRooms = (input)-> map(parseRoom, splitlines(input))

# Each room consists of an encrypted name (lowercase letters separated
# by dashes) followed by a dash, a sector ID, and a checksum in square
# brackets.
parseRoom = (str) -> # [name, id, checksum]
  let parts = split(str, "[") in
  let checksum = slice(first(rest(parts)), 0, 5) in
  let nameAndId = reverse(split(first(parts), "-")) in
  let id = parseInt(first(nameAndId)) in
  let name = foldr(strcat, "", reverse(rest(nameAndId))) in
  [name, id, checksum]

roomName = (r) -> first(r)
roomId = (r) -> first(rest(r))
roomChecksum = (r) -> first(rest(rest(r)))


# A room is real (not a decoy) if the checksum is the five most common
# letters in the encrypted name, in order, with ties broken by
# alphabetization.
isRoomReal = (room) ->
  computeChecksum(roomName(room)) == roomChecksum(room)

computeChecksum = (name) ->
  let sortedChars = sortBy(ord, splitchars(name)) in
  let runs = uniq(sortedChars) in
  let chars = map(first, sortBy(compose((-), length), runs)) in
  # chars is sorted by frequency, but since its input was sorted ascii-betically,
  # any tie in frequency is broken by ascii-betical order.
  # And since all the chars are lowercase, ascii-betical == alphabetical.
  foldr(strcat, "", take(5, chars))

# group consecutive items
uniq = (items) ->  # [a, a, a, b, b ...] -> [[a, a, a], [b, b], ...]
  if isEmpty(items) then []
  else cons(takeWhile((item) -> item == first(items), items),
            uniq(dropWhile((item) -> item == first(items), items)))