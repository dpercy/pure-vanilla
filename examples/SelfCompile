#lang vanilla

using Prelude
using Syntax

# syntax helper
cases = (v, handlers) ->
  if isEmpty(handlers) then error("no case")
  else (
    let h0 = first(handlers) in
    let tag = first(h0) in
    let f = first(rest(h0)) in
    let maybeContents = unpack(tag, v) in
    if maybeContents != false then apply(f, maybeContents)
    else cases(v, rest(handlers)))

addBetween = (lst, sep) ->
  if isEmpty(lst) then lst
  else if isEmpty(rest(lst)) then lst
  else cons(first(lst), cons(sep, addBetween(rest(lst), sep)))
assert(==, addBetween([1,2,3], 0), [1,0,2,0,3])

commaSep = lst -> apply(strcat, addBetween(lst, ", "))

# simple js math compiler
compile = expr -> cases(expr, [
  [:Lit, compileValue],
  [:Quote, compileValue],
  [:Local, (name, num) -> strcat(name, "_", show(num))],
  [:Global, (mod, name) -> strcat(mod, "[", compile(pack(:Lit, name)), "]")],
  [:Func, (params, body) ->
                   parens(
                     strcat(parens(commaSep(map(compile, params))),
                            " => ",
                            compile(body)))],
  [:Call, (func, args) ->
                   strcat("(1,", compile(func), ")(", commaSep(map(compile, args)), ")")],
  [:If, (t, c, a) ->
          let test = compile(t) in
          let test = strcat("Base.bool(", test, ")") in
          strcat("(", test, ")?(", compile(c), "):(", compile(a), ")")],
])

compileValue = expr ->  # TODO rename to value
if isFunc(expr) then compile(inspect(expr))
else if isNumber(expr) then (
  if denominator(expr) == 1 then strcat("Base.num(", show(expr), ")")
  else strcat("Base.num(",
              show(numerator(expr)), ", ",
              show(denominator(expr)), ")"))
else if	isEmpty(expr) then "Base.list()"
else if isPair(expr) then strcat("Base.list(",
                                 commaSep(map(compileValue, expr)),
                                 ")")
else if not(isSyntax(expr)) then show(expr)
else "Base.error('syntax in JS land not supported yet')"

parens = s -> strcat("(", s, ")")

assert(==, compileValue(x -> x), "((x_0) => x_0)")
assert(==, compileValue(() -> 1), "(() => Base.num(1))")
assert(==, compileValue((x, y) -> y), "((x_0, y_0) => y_0)")
assert(==, compileValue(x -> x + 1), "((x_0) => (1,Base[\"+\"])(x_0, Base.num(1)))")
assert(==, compileValue(() -> if 1 then 2 else 3 + 4),
           "(() => (Base.bool(Base.num(1)))?(Base.num(2)):((1,Base[\"+\"])(Base.num(3), Base.num(4))))")
assert(==, compileValue(3/4), "Base.num(3, 4)")


compileModule = sym ->
  let syms = getSiblings(sym) in
  let mod = first(unpack(:Global, sym)) in
  strcat("var ", mod, " = {};\n",
         apply(strcat, map(compileDef, syms)))

compileDef = sym ->
  let v = getValue(sym) in
  strcat("var ", compile(sym), " = ", compileValue(v), ";\n")
