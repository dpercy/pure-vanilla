#lang vanilla

using Prelude
using Syntax

# syntax helper
cases = (v, handlers) ->
  if isEmpty(handlers) then error("no case")
  else (
    let h0 = first(handlers) in
    let tag = first(h0) in
    let f = first(rest(h0)) in
    let maybeContents = unpack(tag, v) in
    if maybeContents != false then apply(f, maybeContents)
    else cases(v, rest(handlers)))

addBetween = (lst, sep) ->
  if isEmpty(lst) then lst
  else if isEmpty(rest(lst)) then lst
  else cons(first(lst), cons(sep, addBetween(rest(lst), sep)))
assert(==, addBetween([1,2,3], 0), [1,0,2,0,3])

commaSep = lst -> apply(strcat, addBetween(lst, ", "))

# simple js math compiler
compile = expr -> cases(expr, [
  [:Lit, compileValue],
  [:Quote, compileValue],
  [:Local, (name, num) -> strcat(name, "_", show(num))],
  [:Global, (mod, name) -> strcat(mod, "[", compile(pack(:Lit, name)), "]")],
  [:Func, (params, body) ->
                   parens(
                     strcat(parens(commaSep(map(compile, params))),
                            " => ",
                            compile(body)))],
  [:Call, (func, args) ->
                   strcat("(1,", compile(func), ")(", commaSep(map(compile, args)), ")")],
  [:If, (t, c, a) -> strcat("(", compile(t), ")?(", compile(c), "):(", compile(a), ")")],
])

compileValue = expr ->
if isFunc(expr) then compile(inspect(expr))
else if not(isSyntax(expr)) then show(expr)
else cases(expr, [
  # TODO need to access source loc here
  [:Lit, (v) -> error("TODO return a string that JS-evaluates to a tree representing a Lit expression")],
])


parens = s -> strcat("(", s, ")")

# TODO need to enforce arity errors
assert(==, compileValue(x -> x), "((x_0) => x_0)")
assert(==, compileValue(() -> 1), "(() => 1)")
assert(==, compileValue((x, y) -> y), "((x_0, y_0) => y_0)")
assert(==, compileValue(x -> x + 1), "((x_0) => (1,Base[\"+\"])(x_0, 1))")
# TODO conditionals should error if test isn't boolean
assert(==, compileValue(() -> if 1 then 2 else 3 + 4), "(() => (1)?(2):((1,Base[\"+\"])(3, 4)))")
